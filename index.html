<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebUTAU — UTAU風クローン（できるだけ本家再現）</title>
<style>
:root{
  --bg:#e9eef6; --panel:#cbd6e8; --line:#a6b6d0; --note:#7fb7ff; --note-sel:#ff9fb8; --text:#102030;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Meiryo, 'Hiragino Kaku Gothic ProN', 'Segoe UI', Arial, sans-serif}
/* top menu like UTAU */
#menu{display:flex;gap:8px;padding:6px 8px;background:#f6f8fb;border-bottom:1px solid var(--line);align-items:center}
.menu-group{display:flex;gap:6px;align-items:center}
.menu-title{font-weight:700;color:#1b2b44;margin-right:6px}
.icon-btn{background:#fff;border:1px solid var(--line);padding:6px 8px;border-radius:4px;cursor:pointer}
.icon-btn:hover{background:#f0f6ff}
.toolbar{display:flex;gap:8px;padding:8px;border-bottom:1px solid var(--line);background:linear-gradient(#f7fbff,#eef4ff)}
.toolbar .group{display:flex;gap:6px;align-items:center}
.input{padding:6px;border:1px solid var(--line);border-radius:4px;background:#fff}
.container{display:flex;height:calc(100% - 106px);}
.leftPane{width:104px;background:#f5f8fb;border-right:1px solid var(--line);padding:8px}
.keys{position:relative;height:100%;overflow:hidden}
.key{height:20px;border-bottom:1px solid #d6dced;display:flex;align-items:center;justify-content:center;font-size:11px;color:#2b4666}
.rightPane{flex:1;display:flex;flex-direction:column}
.topArea{height:40px;padding:6px 8px;border-bottom:1px solid var(--line);display:flex;align-items:center;gap:8px;background:linear-gradient(#fff,#f3f7ff)}
.canvasWrap{flex:1;overflow:auto;position:relative;background:linear-gradient(#ffffff,#eef4ff)}
#roll{display:block}
.statusbar{height:36px;border-top:1px solid var(--line);display:flex;align-items:center;gap:12px;padding:6px 8px;background:#f7fbff}
.small{font-size:12px;color:#4b678a}
.note-lyric{font-weight:700}
/* tooltip */
.tooltip{position:absolute;padding:6px;background:#25344d;color:#fff;border-radius:4px;font-size:12px;pointer-events:none}
</style>
</head>
<body>
<!-- Menu bar (UTAU-like) -->
<div id="menu">
  <div class="menu-group"><span class="menu-title">ファイル</span><button class="icon-btn" id="mNew">新規</button><button class="icon-btn" id="mOpen">開く</button><button class="icon-btn" id="mSave">保存</button></div>
  <div class="menu-group"><span class="menu-title">編集</span><button class="icon-btn" id="mUndo">元に戻す</button><button class="icon-btn" id="mRedo">やり直し</button></div>
  <div class="menu-group"><span class="menu-title">表示</span><button class="icon-btn" id="mZoomIn">拡大</button><button class="icon-btn" id="mZoomOut">縮小</button></div>
  <div style="flex:1"></div>
  <div class="menu-group small">Tempo <input id="tempo" class="input" type="number" value="120" style="width:70px"> PPQ <input id="ppq" class="input" type="number" value="480" style="width:70px"></div>
</div>

<!-- Toolbar (buttons like UTAU) -->
<div class="toolbar">
  <div class="group"><button class="icon-btn" id="play">▶</button><button class="icon-btn" id="pause">||</button><button class="icon-btn" id="stop">■</button></div>
  <div class="group"><button class="icon-btn" id="render">Render</button><button class="icon-btn" id="export">WAV</button></div>
  <div class="group"><button class="icon-btn" id="loadVb">Voicebank 読込</button><button class="icon-btn" id="loadDefault">デフォルト(teto)読み込み</button></div>
  <div class="group small">Quantize <select id="quant" class="input"><option value="480">1/4</option><option value="240">1/8</option><option value="120" selected>1/16</option><option value="60">1/32</option></select></div>
  <div style="flex:1"></div>
  <div class="group small">Lyric <input id="lyricBox" class="input" style="width:120px" placeholder="歌詞を入力"></div>
</div>

<div class="container">
  <!-- left panel: piano keys & controls -->
  <div class="leftPane">
    <div style="font-weight:700;margin-bottom:6px">Piano</div>
    <div class="keys" id="keys"></div>
  </div>

  <!-- right: piano roll and controls -->
  <div class="rightPane">
    <div class="topArea small">
      <div>Mode: <select id="mode" class="input"><option>Normal</option><option>Note</option><option>Pitch</option></select></div>
      <div style="margin-left:12px">Snap: <input type="checkbox" id="snap" checked></div>
      <div style="margin-left:12px">BPM: <span id="bpmDisplay">120</span></div>
      <div style="margin-left:12px">Voicebank: <span id="vbName">(未読み込み)</span></div>
    </div>

    <div class="canvasWrap" id="canvasWrap">
      <canvas id="roll"></canvas>
      <div id="tooltip" class="tooltip" style="display:none"></div>
    </div>

    <div class="statusbar">
      <div class="small">Selected: <span id="sel">None</span></div>
      <div class="small">Tick: <span id="tick">0</span></div>
      <div class="small">Length: <span id="len">0</span></div>
      <div style="flex:1"></div>
      <div class="small">Tips: ダブルクリックで歌詞, Altドラッグで移動, 端をドラッグで長さ変更</div>
    </div>
  </div>
</div>

<!-- hidden inputs for file open -->
<input id="fileOpen" type="file" accept=".json,.ust" style="display:none">
<input id="vbDirPicker" type="file" webkitdirectory directory multiple style="display:none">

<script>
/* ====================================================
   WebUTAU — UTAU風フルUI（見た目＋機能をできるだけ再現）
   - Piano roll with piano keys
   - Note editing (create/move/resize/delete/double-click lyric)
   - Quantize, Tempo, PPQ
   - Voicebank oto.ini loader + default ./teto/ support
   - Offline render + WAV export
   - Touch/pointer support for iOS
   ==================================================== */

// Basic project model
let PPQ = 480;
let BPM = 120;
let quantize = 120; // ticks
let notes = []; // {id, tickOn, tickDur, pitch, lyric}
let nextId = 1;
let selection = null;
let vb = null; // {name, entries: Map(alias->entry), wavCache: Map(file->AudioBuffer)}

// UI refs
const canvasWrap = document.getElementById('canvasWrap');
const roll = document.getElementById('roll');
const ctx = roll.getContext('2d');
const keysEl = document.getElementById('keys');
const ppm = { pxPerTick: 0.12, keyHeight: 20, lowest: 36, highest: 96 };

// audio
let audioCtx = null;
async function ensureAudio(){ if(audioCtx && audioCtx.state!=='closed') return audioCtx; audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return audioCtx; }
function decodeAudioDataSafe(ac, arrayBuffer){ return new Promise((res,rej)=>{ try{ const p = ac.decodeAudioData(arrayBuffer.slice(0)); if(p && p.then) p.then(res).catch(()=>ac.decodeAudioData(arrayBuffer.slice(0),res,rej)); else ac.decodeAudioData(arrayBuffer.slice(0),res,rej); }catch(e){ ac.decodeAudioData(arrayBuffer.slice(0),res,rej); } }); }

// layout
function resizeCanvas(){ const w = Math.max(2000, Math.ceil((getProjectLengthTicks()+480) * ppm.pxPerTick)); const h = (ppm.highest - ppm.lowest) * ppm.keyHeight; roll.width = w; roll.height = h; canvasWrap.scrollLeft = 0; canvasWrap.scrollTop = 0; renderKeys(); draw(); }
window.addEventListener('resize', resizeCanvas);

function getProjectLengthTicks(){ if(notes.length===0) return 1920; return Math.max(...notes.map(n=>n.tickOn + n.tickDur)); }

// draw piano keys left panel
function renderKeys(){ keysEl.innerHTML=''; const h = (ppm.highest - ppm.lowest) * ppm.keyHeight; keysEl.style.height = h+'px'; for(let m=ppm.lowest; m<ppm.highest; m++){ const div = document.createElement('div'); div.className='key'; div.style.height = ppm.keyHeight+'px'; div.textContent = midiToName(m); if([1,3,6,8,10].includes(m%12)) div.style.background='#e8edf8'; keysEl.appendChild(div); }}
function midiToName(n){ const names=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B']; return names[n%12]+Math.floor(n/12-1); }

// utilities
function ticksToX(t){ return Math.round(t * ppm.pxPerTick); }
function xToTicks(x){ return Math.round(x / ppm.pxPerTick); }
function pitchToY(p){ return (ppm.highest - p - 1) * ppm.keyHeight; }
function snapTick(t){ if(!document.getElementById('snap').checked) return t; const q = parseInt(document.getElementById('quant').value,10); return Math.round(t / q) * q; }

// drawing
function draw(){ ctx.clearRect(0,0,roll.width,roll.height);
  // background rows
  for(let p=ppm.lowest;p<ppm.highest;p++){ const y = pitchToY(p); ctx.fillStyle = ([1,3,6,8,10].includes(p%12))? '#f5f7fb':'#ffffff'; ctx.fillRect(0,y,roll.width,ppm.keyHeight); ctx.strokeStyle='#e0e7f2'; ctx.beginPath(); ctx.moveTo(0,y+ppm.keyHeight); ctx.lineTo(roll.width,y+ppm.keyHeight); ctx.stroke(); }
  // vertical beat lines (measure/beat)
  const beatTicks = PPQ; const barTicks = beatTicks * 4; // assuming 4/4 default
  for(let t=0;t<getProjectLengthTicks();t+=PPQ/4){ const x = ticksToX(t); ctx.strokeStyle = (t%barTicks===0)?'#ff7f7f':'#d0d8ea'; ctx.lineWidth = (t%barTicks===0)?1.2:0.7; ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,roll.height); ctx.stroke(); }
  // notes
  for(const n of notes){ const x = ticksToX(n.tickOn), y = pitchToY(n.pitch); const w = Math.max(4,ticksToX(n.tickDur)); const sel = (selection===n.id);
    ctx.fillStyle = sel? 'var(--note-sel)':'var(--note)'; ctx.strokeStyle = sel? '#ff6f8f' : '#407fcf'; roundRect(ctx,x+0.5,y+2.5,w-1,ppm.keyHeight-5,6,true,true); ctx.fillStyle='#02243a'; ctx.fillRect(x+6,y+6,Math.min(80,w-12),ppm.keyHeight-12); ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.fillText(n.lyric||'', x+8, y+ppm.keyHeight-6); }
}

// rounded rect helper
function roundRect(ctx,x,y,w,h,r,fill,stroke){ if(w<2*r) r=w/2; if(h<2*r) r=h/2; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke(); }

// input handlers (pointer based for iOS)
let dragging = null; // {mode, id, startX,startY, orig}
roll.addEventListener('pointerdown', (e)=>{ roll.setPointerCapture?.(e.pointerId); const rect = roll.getBoundingClientRect(); const x = e.clientX - rect.left + roll.parentElement.scrollLeft; const y = e.clientY - rect.top + roll.parentElement.scrollTop; const tick = snapTick(xToTicks(x)); const pitch = clamp(ppm.lowest, ppm.highest-1, Math.floor(ppm.highest - (y/ppm.keyHeight))); const hit = notes.slice().reverse().find(n=>{ const nx=ticksToX(n.tickOn), ny=pitchToY(n.pitch), nw=Math.max(4,ticksToX(n.tickDur)); return x>=nx && x<=nx+nw && y>=ny && y<=ny+ppm.keyHeight; });
  if(hit){ selection = hit.id; document.getElementById('sel')?.innerText = selection; // determine if on edge
    const nx = ticksToX(hit.tickOn), nw = Math.max(4,ticksToX(hit.tickDur)); if(Math.abs(x - nx) < 8){ dragging = {mode:'resizeL', id:hit.id, startX:x, orig:{...hit}}; } else if(Math.abs(x - (nx+nw)) < 8){ dragging = {mode:'resizeR', id:hit.id, startX:x, orig:{...hit}}; } else if(e.altKey || e.shiftKey){ dragging={mode:'move', id:hit.id, startX:x, startY:y, orig:{...hit}}; } else { // select only
      dragging = {mode:'select', id:hit.id}; }
  } else { // create new note
    const id = nextId++; const note = { id, tickOn: tick, tickDur: PPQ, pitch, lyric: document.getElementById('lyricBox').value || 'あ' }; notes.push(note); selection = id; dragging = {mode:'resizeR', id, startX:x, orig:{...note}}; }
  draw(); updateStatus(); });

roll.addEventListener('pointermove', (e)=>{ if(!dragging) return; const rect=roll.getBoundingClientRect(); const x=e.clientX-rect.left + roll.parentElement.scrollLeft; const y=e.clientY-rect.top + roll.parentElement.scrollTop; const n = notes.find(z=>z.id===dragging.id); if(!n) return; if(dragging.mode==='move'){ const dx = x - dragging.startX; const dy = y - dragging.startY; const newTick = snapTick(dragging.orig.tickOn + xToTicks(dx)); const newPitch = clamp(ppm.lowest, ppm.highest-1, dragging.orig.pitch - Math.round(dy/ppm.keyHeight)); n.tickOn = Math.max(0, newTick); n.pitch = newPitch; } else if(dragging.mode==='resizeR'){ const newDur = Math.max(30, xToTicks(dragging.orig.tickOn + dragging.orig.tickDur) - dragging.orig.tickOn + xToTicks(x - dragging.startX)); n.tickDur = Math.max(30, xToTicks(dragging.orig.tickDur + (x - dragging.startX))); } else if(dragging.mode==='resizeL'){ const newOn = Math.max(0, snapTick(dragging.orig.tickOn + xToTicks(x - dragging.startX))); const delta = dragging.orig.tickOn - newOn; n.tickOn = newOn; n.tickDur = Math.max(30, dragging.orig.tickDur + delta); }
  draw(); updateStatus(); });

window.addEventListener('pointerup', (e)=>{ try{ roll.releasePointerCapture?.(e.pointerId); }catch(_){} dragging=null; });

// double click for lyric edit
roll.addEventListener('dblclick', (e)=>{ const rect = roll.getBoundingClientRect(); const x = e.clientX - rect.left + roll.parentElement.scrollLeft; const y = e.clientY - rect.top + roll.parentElement.scrollTop; const hit = notes.slice().reverse().find(n=>{ const nx=ticksToX(n.tickOn), ny=pitchToY(n.pitch), nw=Math.max(4,ticksToX(n.tickDur)); return x>=nx && x<=nx+nw && y>=ny && y<=ny+ppm.keyHeight; }); if(hit){ const v = prompt('歌詞を入力', hit.lyric); if(v!==null){ hit.lyric = v; draw(); } } });

// right click delete
roll.addEventListener('contextmenu', (e)=>{ e.preventDefault(); const rect = roll.getBoundingClientRect(); const x = e.clientX - rect.left + roll.parentElement.scrollLeft; const y = e.clientY - rect.top + roll.parentElement.scrollTop; const idx = notes.findIndex(n=>{ const nx=ticksToX(n.tickOn), ny=pitchToY(n.pitch), nw=Math.max(4,ticksToX(n.tickDur)); return x>=nx && x<=nx+nw && y>=ny && y<=ny+ppm.keyHeight; }); if(idx>=0){ if(confirm('ノートを削除しますか？')){ notes.splice(idx,1); selection=null; draw(); updateStatus(); } } });

// helpers
function clamp(a,b,v){ return Math.max(a, Math.min(b, v)); }
function updateStatus(){ document.getElementById('sel').innerText = selection || 'None'; document.getElementById('tick').innerText = selection? (notes.find(n=>n.id===selection)?.tickOn || 0) : 0; document.getElementById('len').innerText = selection? (notes.find(n=>n.id===selection)?.tickDur || 0) : 0; }

// file operations
document.getElementById('mNew').addEventListener('click', ()=>{ notes=[]; selection=null; draw(); updateStatus(); });
document.getElementById('mSave').addEventListener('click', ()=>{ const pj = { version:1, ppq:PPQ, bpm:BPM, notes }; const blob = new Blob([JSON.stringify(pj,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='project.json'; a.click(); });

document.getElementById('mOpen').addEventListener('click', ()=>document.getElementById('fileOpen').click());
document.getElementById('fileOpen').addEventListener('change', async (e)=>{ const f = e.target.files[0]; if(!f) return; const txt = await f.text(); try{ const pj = JSON.parse(txt); if(pj.notes){ notes = pj.notes; PPQ = pj.ppq || PPQ; BPM = pj.bpm || BPM; updateStatus(); resizeCanvas(); draw(); return; } }catch(_){} // fallback simplistic UST parse
  const lines = txt.split(/\r?\n/); let tick=0; notes=[]; for(const ln of lines){ const m=/^NoteNum=(\d+)/.exec(ln); const ml=/^Length=(\d+)/.exec(ln); const my=/^Lyric=(.*)/.exec(ln); if(m && ml && my){ const pitch=parseInt(m[1],10); const len=parseInt(ml[1],10); const lyric=my[1].trim(); notes.push({ id: nextId++, tickOn: tick, tickDur: len, pitch, lyric }); tick+=len; } } resizeCanvas(); draw(); });

// voicebank loader (directory picker fallback to individual files) and default teto loader
async function parseOtoText(text, dirHandle){ const entries = new Map(); const lines = text.split(/\r?\n/); for(const line of lines){ if(!line.trim()) continue; const eq = line.indexOf('='); if(eq<0) continue; const left = line.slice(0,eq); const right = line.slice(eq+1); const comma = left.indexOf(','); if(comma<0) continue; const file = left.slice(0,comma).trim(); const alias = left.slice(comma+1).trim(); let vals = right.trim().split(/\s+/); if(vals.length<5) vals = right.split(',').map(s=>s.trim()); const nums = vals.map(s=>parseFloat(s)||0); entries.set(alias, { file, alias, offset: nums[0]||0, consonant: nums[1]||0, cutoff: nums[2]||0, preutter: nums[3]||0, overlap: nums[4]||0, dir: dirHandle }); } return entries; }

async function loadDefaultTeto(){ try{ const base = './teto/'; const otoText = await (await fetch(base+'oto.ini')).text(); const entries = await parseOtoText(otoText, null); const vbObj = { name:'teto', entries: entries, wavCache: new Map(), dir: null }; // load wavs
  const names = new Set(Array.from(entries.values()).map(e=>e.file)); await ensureAudio(); for(const fn of names){ try{ const res = await fetch(base + 'wav/' + fn); if(!res.ok) throw new Error('notfound'); const ab = await res.arrayBuffer(); const buf = await decodeAudioDataSafe(audioCtx, ab); vbObj.wavCache.set(fn.toLowerCase(), buf); }catch(e){ console.warn('load wav fail', fn, e); } }
  vb = vbObj; document.getElementById('vbName').innerText = vb.name + ' ('+vb.entries.size+' aliases)'; alert('デフォルト音源をロードしました'); }catch(e){ console.error(e); alert('デフォルト音源の読み込みに失敗しました'); } }

document.getElementById('loadDefault').addEventListener('click', loadDefaultTeto);

// schedule render using OfflineAudioContext and simple wavtool-like concatenation
async function renderOffline(){ await ensureAudio(); const totalTicks = getProjectLengthTicks(); const secPerTick = 60 / BPM / PPQ; const duration = Math.ceil(totalTicks * secPerTick + 1); const offline = new OfflineAudioContext(1, Math.ceil(duration * audioCtx.sampleRate), audioCtx.sampleRate);
  const notesSorted = notes.slice().sort((a,b)=>a.tickOn-b.tickOn);
  for(const n of notesSorted){ const entry = vb?.entries.get(n.lyric) || vb?.entries.get(n.lyric.trim()); if(!entry){ // fallback beeps
      const osc = offline.createOscillator(); const g=offline.createGain(); const t0 = n.tickOn * secPerTick; const t1 = t0 + Math.max(0.05, n.tickDur * secPerTick); osc.type='sine'; osc.frequency.value = 440 * Math.pow(2, (n.pitch-69)/12); osc.connect(g); g.connect(offline.destination); g.gain.setValueAtTime(0,t0); g.gain.linearRampToValueAtTime(0.8,t0+0.01); g.gain.setValueAtTime(0.8,t1-0.02); g.gain.linearRampToValueAtTime(0,t1); osc.start(t0); osc.stop(t1); continue; }
    const buf = vb.wavCache.get(entry.file.toLowerCase()); if(!buf) continue; const pre = (entry.preutter||0)/1000; const offsetSec = Math.max(0,(entry.offset||0)/1000); const tNote = n.tickOn * secPerTick; const startPlay = Math.max(0, tNote - pre);
    // schedule source from offset
    const src = offline.createBufferSource(); src.buffer = buf; // pitch shifting using playbackRate (coarse)
    const baseMidi = 60; // crude base
    const rate = Math.pow(2, (n.pitch - baseMidi)/12);
    src.playbackRate.value = rate;
    const g = offline.createGain(); const plannedStop = startPlay + Math.min(buf.duration - offsetSec, Math.max(0.05, n.tickDur * secPerTick + 0.05)); g.gain.setValueAtTime(0,startPlay); g.gain.linearRampToValueAtTime(1,startPlay+0.01); g.gain.setValueAtTime(1,plannedStop-0.02); g.gain.linearRampToValueAtTime(0,plannedStop);
    src.connect(g).connect(offline.destination);
    src.start(startPlay, offsetSec);
    src.stop(plannedStop);
  }
  return offline.startRendering(); }

// play/export handlers
document.getElementById('render').addEventListener('click', async ()=>{ try{ const buf = await renderOffline(); alert('レンダリング完了 ('+Math.round(buf.duration*1000)+' ms)'); }catch(e){ console.error(e); alert('レンダリング失敗'); } });

document.getElementById('export').addEventListener('click', async ()=>{ try{ const rendered = await renderOffline(); // convert to wav
    const wav = audioBufferToWav(rendered); const blob = new Blob([wav], {type:'audio/wav'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'render.wav'; a.click(); }catch(e){ console.error(e); alert('書き出し失敗'); } });

function audioBufferToWav(buffer){ const numOfChan = buffer.numberOfChannels; const length = buffer.length; const sampleRate = buffer.sampleRate; const bytes = 44 + length * numOfChan * 2; const ab = new ArrayBuffer(bytes); const view = new DataView(ab); let offset = 0; function writeStr(s){ for(let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); }
  writeStr('RIFF'); view.setUint32(offset,36 + length * numOfChan * 2, true); offset+=4; writeStr('WAVE'); writeStr('fmt '); view.setUint32(offset,16,true); offset+=4; view.setUint16(offset,1,true); offset+=2; view.setUint16(offset,numOfChan,true); offset+=2; view.setUint32(offset,sampleRate,true); offset+=4; view.setUint32(offset,sampleRate*numOfChan*2,true); offset+=4; view.setUint16(offset,numOfChan*2,true); offset+=2; view.setUint16(offset,16,true); offset+=2; writeStr('data'); view.setUint32(offset,length * numOfChan * 2, true); offset+=4;
  // interleave
  for(let i=0;i<length;i++){ for(let ch=0; ch<numOfChan; ch++){ let v = buffer.getChannelData(ch)[i]; v = Math.max(-1, Math.min(1, v)); view.setInt16(offset, v < 0 ? v*0x8000 : v*0x7FFF, true); offset += 2; } }
  return ab; }

// utils
function audioLog(msg){ console.log('[Audio]', msg); }

// init
renderKeys(); resizeCanvas(); draw(); updateStatus();

// zoom controls
document.getElementById('mZoomIn').addEventListener('click', ()=>{ ppm.pxPerTick *= 1.25; resizeCanvas(); draw(); });
document.getElementById('mZoomOut').addEventListener('click', ()=>{ ppm.pxPerTick /= 1.25; resizeCanvas(); draw(); });

document.getElementById('tempo').addEventListener('change', (e)=>{ BPM = parseFloat(e.target.value)||120; document.getElementById('bpmDisplay').innerText = BPM; });

document.getElementById('quant').addEventListener('change', ()=>{});

</script>
</body>
</html>
