<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web UTAU JS — Foundation</title>
  <style>
    :root {
      --bg: #0f1115; --panel: #171a21; --muted:#9aa5b1; --fg:#e6edf3; --accent:#5b9cff; --accent2:#7ee787; --danger:#ff6b6b;
      --grid1:#1f232b; --grid2:#151821; --beat:#2a2f3a; --bar:#3a4150; --note:#7aa2ff; --note-sel:#ffd166;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; background: var(--bg); color: var(--fg); margin: 0; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP", sans-serif; }
    #app { display: grid; grid-template-rows: 48px 1fr 28px; height: 100%; }
    .toolbar { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--panel); border-bottom: 1px solid #202431; position: sticky; top: 0; z-index: 2; }
    .toolbar .title { font-weight: 700; margin-right: 12px; }
    .btn { background: #253044; color: var(--fg); border: 1px solid #2d374f; padding: 6px 10px; border-radius: 8px; cursor: pointer; }
    .btn:hover { background: #2b3952; }
    .btn.primary { background: var(--accent); border-color: transparent; color: #0a0e14; font-weight: 700; }
    .btn.danger { background: var(--danger); border-color: transparent; color: #0a0e14; font-weight: 700; }
    .sep { width: 1px; height: 24px; background:#2a3142; margin: 0 4px; }

    .main { display: grid; grid-template-columns: 72px 1fr; overflow: hidden; }
    .keys { background: var(--panel); border-right: 1px solid #202431; position: relative; }
    .roll-wrap { position: relative; overflow: auto; background: var(--grid2); }
    canvas { display: block; }

    .statusbar { background: var(--panel); border-top: 1px solid #202431; display:flex; align-items:center; gap:16px; padding: 4px 8px; color: var(--muted); }

    /* key styles */
    .key { position: absolute; left: 0; right: 0; height: 16px; border-bottom: 1px solid #202431; display:flex; align-items:center; justify-content:center; font-size: 10px; color: var(--muted); }

    /* piano roll metrics */
  </style>
</head>
<body>
<div id="app">
  <div class="toolbar">
    <div class="title">Web UTAU JS — 土台</div>
    <button class="btn" id="btnNew">新規</button>
    <button class="btn" id="btnOpen">開く</button>
    <button class="btn" id="btnSave">保存</button>
    <div class="sep"></div>
    <label style="display:flex;align-items:center;gap:6px;color:var(--muted)">
      BPM <input id="bpm" type="number" min="30" max="300" value="120" style="width:72px;background:#0f141c;color:#e6edf3;border:1px solid #2d374f;border-radius:6px;padding:4px 6px">
    </label>
    <label style="display:flex;align-items:center;gap:6px;color:var(--muted);margin-left:8px">
      拍子 <input id="num" type="number" min="1" max="12" value="4" style="width:48px;background:#0f141c;color:#e6edf3;border:1px solid #2d374f;border-radius:6px;padding:4px 6px">
      / <input id="den" type="number" min="1" max="16" value="4" style="width:48px;background:#0f141c;color:#e6edf3;border:1px solid #2d374f;border-radius:6px;padding:4px 6px">
    </label>
    <div class="sep"></div>
    <button class="btn" id="btnPlay">再生</button>
    <button class="btn" id="btnStop">停止</button>
    <button class="btn primary" id="btnExport">WAV書き出し</button>
    <div class="sep"></div>
    <span id="hint" style="color:var(--muted)">ドラッグでノート作成 / クリックで選択 / Alt+ドラッグで移動 / 端をドラッグで長さ変更</span>
    <input type="file" id="fileOpen" accept="application/json" style="display:none" />
  </div>

  <div class="main">
    <div class="keys" id="keys"></div>
    <div class="roll-wrap" id="rollWrap"><canvas id="roll" width="2400" height="1024"></canvas></div>
  </div>

  <div class="statusbar">
    <div>PPQ: <span id="ppq">480</span></div>
    <div>選択: <span id="sel">なし</span></div>
    <div>長さ: <span id="len">0</span> tick</div>
    <div>位置: <span id="pos">0</span> tick</div>
  </div>
</div>

<script>
// ======= 基本データモデル =======
const PPQ = 480; // pulses per quarter note
const state = {
  bpm: 120,
  timeSig: { num: 4, den: 4 },
  notes: /** @type {Note[]} */ ([]),
  selection: null, // note id
  nextId: 1,
};

/** @typedef {{id:number, tickOn:number, tickDur:number, pitch:number, lyric:string}} Note */

// ======= UI サイズ・スケール =======
const metrics = {
  keyHeight: 16,         // px per semitone
  pxPerTick: 0.1,        // horizontal zoom
  lowestKey: 36,         // C2
  highestKey: 96,        // C7 (exclusive)
  leftGutter: 72,        // width of keys panel
};

// DOM 参照
const elKeys = document.getElementById('keys');
const elCanvas = document.getElementById('roll');
const ctx = elCanvas.getContext('2d');
const elWrap = document.getElementById('rollWrap');
const elBpm = document.getElementById('bpm');
const elNum = document.getElementById('num');
const elDen = document.getElementById('den');
const elPPQ = document.getElementById('ppq');
const elSel = document.getElementById('sel');
const elLen = document.getElementById('len');
const elPos = document.getElementById('pos');
const elFileOpen = document.getElementById('fileOpen');

// ======= ピアノ鍵盤の描画（左パネル、DOMで） =======
function renderKeys() {
  elKeys.innerHTML = '';
  const h = (metrics.highestKey - metrics.lowestKey) * metrics.keyHeight;
  elKeys.style.height = h + 'px';
  for (let m = metrics.lowestKey; m < metrics.highestKey; m++) {
    const div = document.createElement('div');
    div.className = 'key';
    const y = (metrics.highestKey - m - 1) * metrics.keyHeight;
    div.style.top = y + 'px';
    div.style.height = metrics.keyHeight + 'px';
    const name = midiToName(m);
    div.textContent = name;
    if (name.includes('#')) div.style.background = '#121520';
    elKeys.appendChild(div);
  }
}

function midiToName(n) {
  const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const o = Math.floor(n/12)-1; return names[n%12] + o;
}

// ======= グリッドとノート描画（Canvas） =======
function ticksToX(t) { return t * metrics.pxPerTick; }
function pitchToY(p) { return (metrics.highestKey - p - 1) * metrics.keyHeight; }

function draw() {
  const w = elCanvas.width, h = elCanvas.height;
  ctx.clearRect(0,0,w,h);

  // 背景 & 横グリッド（鍵盤ライン）
  for (let p = metrics.lowestKey; p < metrics.highestKey; p++) {
    const y = pitchToY(p);
    ctx.fillStyle = ((p%12)==1|| (p%12)==3 || (p%12)==6 || (p%12)==8 || (p%12)==10) ? '#151821' : '#1b1f2a';
    ctx.fillRect(0, y, w, metrics.keyHeight);
  }

  // 縦グリッド（拍・小節）
  const beatTicks = PPQ * (4/state.timeSig.den);
  const barTicks = beatTicks * state.timeSig.num;
  const maxTicks = Math.ceil(w / metrics.pxPerTick);
  for (let t = 0; t < maxTicks; t += beatTicks) {
    const x = Math.floor(ticksToX(t)) + 0.5;
    ctx.strokeStyle = (t % barTicks === 0) ? '#3a4150' : '#2a2f3a';
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }

  // ノート
  for (const n of state.notes) {
    const x = ticksToX(n.tickOn), y = pitchToY(n.pitch);
    const w = Math.max(1, ticksToX(n.tickDur));
    const sel = (state.selection === n.id);
    ctx.fillStyle = sel ? '#ffd166' : '#7aa2ff';
    ctx.strokeStyle = sel ? '#facc15' : '#5a86e6';
    roundRect(ctx, x+0.5, y+2.5, w-1, metrics.keyHeight-5, 4, true, true);
  }
}

function roundRect(ctx,x,y,w,h,r,fill,stroke){
  if (w<2*r) r=w/2; if (h<2*r) r=h/2; ctx.beginPath(); ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  if (fill) ctx.fill(); if (stroke) { ctx.lineWidth=1; ctx.stroke(); }
}

// ======= マウス操作 =======
let drag = null; // {mode:'create'|'move'|'resizeL'|'resizeR', id, startX,startY, orig}

elCanvas.addEventListener('mousedown', (e)=>{
  const {tick, pitch, x, y} = posFromEvent(e);
  const hit = hitTest(x, y);
  if (hit) {
    state.selection = hit.id;
    if (nearEdge(hit, x)) {
      drag = { mode: (x < ticksToX(hit.tickOn)+6? 'resizeL' : 'resizeR'), id: hit.id, startX:x, startY:y, orig: {...hit} };
    } else if (e.altKey) {
      drag = { mode:'move', id: hit.id, startX:x, startY:y, orig:{...hit} };
    }
  } else {
    // 新規作成
    const id = state.nextId++;
    const note = { id, tickOn: Math.floor(tick/30)*30, tickDur: PPQ, pitch, lyric: 'a' };
    state.notes.push(note); state.selection = id;
    drag = { mode:'resizeR', id, startX:x, startY:y, orig:{...note} };
  }
  syncStatus(); draw();
});

elCanvas.addEventListener('mousemove', (e)=>{
  if (!drag) return;
  const {tick, pitch, x, y} = posFromEvent(e);
  const note = state.notes.find(n=>n.id===drag.id); if(!note) return;
  const dxTicks = Math.round((x - drag.startX) / metrics.pxPerTick / 15) * 15; // 1/32グリッド
  const dyPitch = Math.round((drag.startY - y) / metrics.keyHeight);

  if (drag.mode==='move') {
    note.tickOn = Math.max(0, drag.orig.tickOn + dxTicks);
    note.pitch = clamp(metrics.lowestKey, metrics.highestKey-1, drag.orig.pitch + dyPitch);
  } else if (drag.mode==='resizeR') {
    note.tickDur = Math.max(30, drag.orig.tickDur + dxTicks);
  } else if (drag.mode==='resizeL') {
    const newOn = Math.max(0, drag.orig.tickOn + dxTicks);
    const delta = note.tickOn - newOn; note.tickOn = newOn; note.tickDur = Math.max(30, drag.orig.tickDur + delta);
  }
  syncStatus(); draw();
});

window.addEventListener('mouseup', ()=>{ drag=null; });

function posFromEvent(e){
  const rect = elCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) + elWrap.scrollLeft;
  const y = (e.clientY - rect.top) + elWrap.scrollTop;
  const tick = Math.max(0, Math.round(x / metrics.pxPerTick));
  const pitch = clamp(metrics.lowestKey, metrics.highestKey-1, metrics.highestKey-1 - Math.floor(y / metrics.keyHeight));
  return { tick, pitch, x, y };
}

function hitTest(x, y){
  for (let i = state.notes.length-1; i>=0; i--) {
    const n = state.notes[i];
    const nx = ticksToX(n.tickOn), ny = pitchToY(n.pitch);
    const nw = ticksToX(n.tickDur), nh = metrics.keyHeight;
    if (x>=nx && x<=nx+nw && y>=ny && y<=ny+nh) return n;
  }
  return null;
}
function nearEdge(n, x){ const left=ticksToX(n.tickOn), right=left+ticksToX(n.tickDur); return Math.abs(x-left)<6 || Math.abs(x-right)<6; }
function clamp(a,b,v){ return Math.max(a, Math.min(b,v)); }

// ======= 再生（シンセの仮実装：サイン波） =======
let ac = null; let playing = false; let stopFn = null;

function ensureAC(){ if(!ac) ac = new (window.AudioContext||window.webkitAudioContext)(); return ac; }

function play(){
  if (playing) return; ensureAC();
  const startAt = ac.currentTime + 0.05;
  const secPerTick = (60/state.bpm) / PPQ;
  const master = ac.createGain(); master.gain.value=0.2; master.connect(ac.destination);

  for (const n of state.notes){
    const t0 = startAt + n.tickOn * secPerTick;
    const t1 = t0 + Math.max(1, n.tickDur) * secPerTick;
    const freq = 440 * Math.pow(2, (n.pitch-69)/12);
    const osc = ac.createOscillator(); osc.type='sine'; osc.frequency.value=freq;
    const g = ac.createGain();
    // 簡易エンベロープ
    const a=0.005,d=0.05,s=0.8,r=0.05;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(1, t0+a);
    g.gain.linearRampToValueAtTime(s, t0+a+d);
    g.gain.setValueAtTime(s, t1-r);
    g.gain.linearRampToValueAtTime(0, t1);
    osc.connect(g).connect(master);
    osc.start(t0); osc.stop(t1);
  }
  playing = true; stopFn = ()=>{ ac && ac.close(); ac=null; playing=false; };
}

function stop(){ if(stopFn) stopFn(); }

async function exportWav(){
  const totalTicks = Math.max(0, ...state.notes.map(n=>n.tickOn+n.tickDur));
  const sampleRate = 44100;
  const duration = (60/state.bpm) * (totalTicks/PPQ) + 0.2; // tail
  const oac = new OfflineAudioContext(1, Math.ceil(sampleRate*duration), sampleRate);
  const secPerTick = (60/state.bpm) / PPQ;
  const master = oac.createGain(); master.gain.value=0.2; master.connect(oac.destination);
  for (const n of state.notes){
    const t0 = n.tickOn * secPerTick;
    const t1 = t0 + Math.max(1, n.tickDur) * secPerTick;
    const freq = 440 * Math.pow(2, (n.pitch-69)/12);
    const osc = oac.createOscillator(); osc.type='sine'; osc.frequency.value=freq;
    const g = oac.createGain();
    const a=0.005,d=0.05,s=0.8,r=0.05;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(1, t0+a);
    g.gain.linearRampToValueAtTime(s, t0+a+d);
    g.gain.setValueAtTime(s, t1-r);
    g.gain.linearRampToValueAtTime(0, t1);
    osc.connect(g).connect(master);
    osc.start(t0); osc.stop(t1);
  }
  const rendered = await oac.startRendering();
  downloadWav(rendered, 'render.wav');
}

function downloadWav(buffer, filename){
  const numChan = buffer.numberOfChannels; const length = buffer.length; const sampleRate = buffer.sampleRate;
  const data = buffer.getChannelData(0);
  const bytes = 44 + length * numChan * 2; const ab = new ArrayBuffer(bytes); const view = new DataView(ab);
  writeStr(view, 0, 'RIFF'); view.setUint32(4, 36 + length*2, true); writeStr(view, 8, 'WAVE');
  writeStr(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numChan, true);
  view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * numChan * 2, true);
  view.setUint16(32, numChan * 2, true); view.setUint16(34, 16, true);
  writeStr(view, 36, 'data'); view.setUint32(40, length * 2, true);
  let off = 44; for (let i=0;i<length;i++,off+=2){ let s = Math.max(-1, Math.min(1, data[i])); view.setInt16(off, s<0 ? s*0x8000 : s*0x7FFF, true); }
  const blob = new Blob([view], {type:'audio/wav'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click();
}
function writeStr(view, off, str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }

// ======= 保存/読み込み =======
function toProject(){ return { version:1, ppq:PPQ, bpm:state.bpm, timeSig:state.timeSig, notes:state.notes }; }
function fromProject(p){ state.bpm=p.bpm||120; state.timeSig=p.timeSig||{num:4,den:4}; state.notes=(p.notes||[]); }

function saveFile(){ const data = JSON.stringify(toProject(), null, 2); const blob = new Blob([data], {type:'application/json'}); const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='project.json'; a.click(); }
async function openFile(){ elFileOpen.value=''; elFileOpen.click(); }
elFileOpen.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; const text=await f.text(); try{ const p=JSON.parse(text); fromProject(p); syncFromInputs(); resizeCanvasToContent(); draw(); }catch(err){ alert('JSONの読み込みに失敗しました'); }});

// ======= ツールバー挙動 =======
function syncFromInputs(){ state.bpm = parseFloat(elBpm.value||'120'); state.timeSig.num = parseInt(elNum.value||'4',10); state.timeSig.den=parseInt(elDen.value||'4',10); syncStatus(); }
function syncStatus(){ elPPQ.textContent=String(PPQ); const sel = state.selection ? state.notes.find(n=>n.id===state.selection) : null; elSel.textContent = sel? `id ${sel.id}` : 'なし'; elLen.textContent = sel? sel.tickDur : 0; elPos.textContent = sel? sel.tickOn : 0; }

// ======= キャンバスサイズ管理 =======
function resizeCanvasToContent(){
  const totalTicks = Math.max(1920, ...state.notes.map(n=>n.tickOn+n.tickDur), 1920);
  const w = Math.ceil(totalTicks * metrics.pxPerTick) + 400;
  const h = (metrics.highestKey - metrics.lowestKey) * metrics.keyHeight;
  elCanvas.width = w; elCanvas.height = h; draw();
}

// ======= イベント結線 =======
window.addEventListener('resize', ()=>draw());
['input','change'].forEach(ev=>{ elBpm.addEventListener(ev, ()=>{ syncFromInputs(); }); elNum.addEventListener(ev, ()=>{ syncFromInputs(); draw(); }); elDen.addEventListener(ev, ()=>{ syncFromInputs(); draw(); }); });

document.getElementById('btnNew').addEventListener('click', ()=>{ state.notes=[]; state.selection=null; draw(); });
document.getElementById('btnOpen').addEventListener('click', openFile);
document.getElementById('btnSave').addEventListener('click', saveFile);
document.getElementById('btnPlay').addEventListener('click', play);
document.getElementById('btnStop').addEventListener('click', stop);
document.getElementById('btnExport').addEventListener('click', exportWav);

// ======= 初期化 =======
renderKeys();
resizeCanvasToContent();
draw();
syncFromInputs();

</script>
</body>
</html>
