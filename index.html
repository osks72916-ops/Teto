<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web UTAU Replica</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }

        #piano-roll-container {
            position: relative;
            width: 90%;
            max-width: 1200px;
            height: 400px;
            border: 1px solid #ccc;
            background-color: #fff;
            overflow: auto;
            cursor: crosshair;
        }

        .piano-grid-line {
            position: absolute;
            background-color: #e0e0e0;
        }

        .piano-grid-line.bar {
            background-color: #a0a0a0;
        }

        .note {
            position: absolute;
            box-sizing: border-box;
            background-color: #4CAF50;
            border: 1px solid #388E3C;
            opacity: 0.8;
            cursor: pointer;
            z-index: 10;
        }

        .note.selected {
            background-color: #FFC107;
            border-color: #FF8F00;
            box-shadow: 0 0 5px rgba(255, 143, 0, 0.5);
        }

        .note-lyrics {
            color: #fff;
            font-size: 12px;
            padding: 2px;
            position: absolute;
            bottom: -20px;
            left: 0;
            white-space: nowrap;
        }
        
        .handle {
            position: absolute;
            width: 8px;
            height: 100%;
            cursor: ew-resize;
            background-color: #ffffff33;
            z-index: 20;
        }

        .handle.left { left: -4px; }
        .handle.right { right: -4px; }

        #controls {
            margin-top: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
        }

        .hidden {
            display: none;
        }

        #editor-panel {
            margin-top: 20px;
            width: 90%;
            max-width: 1200px;
            border: 1px solid #ccc;
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
        }

        .editor-section {
            margin-bottom: 15px;
        }

        .editor-section h3 {
            margin: 0 0 10px 0;
        }

        .editor-canvas {
            width: 100%;
            height: 150px;
            border: 1px solid #ccc;
            cursor: crosshair;
            background-color: #fafafa;
        }

        .vibrato-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .vibrato-controls label {
            width: 60px;
        }

        input[type="range"] {
            flex-grow: 1;
        }
    </style>
</head>
<body>

    <header>
        <h1>簡易UTAU Web版</h1>
    </header>

    <main>
        <div id="piano-roll-container"></div>
        
        <div id="controls">
            <button id="play-btn">再生</button>
            <button id="stop-btn">停止</button>
        </div>

        <div id="editor-panel" class="hidden">
            <h2>ノート編集</h2>
            <div class="editor-section">
                <h3>ピッチカーブ</h3>
                <canvas id="pitch-editor" class="editor-canvas"></canvas>
            </div>
            <div class="editor-section">
                <h3>エンベロープ</h3>
                <canvas id="envelope-editor" class="editor-canvas"></canvas>
            </div>
            <div class="editor-section">
                <h3>ビブラート</h3>
                <div class="vibrato-controls">
                    <label for="vibrato-depth">深さ:</label>
                    <input type="range" id="vibrato-depth" min="0" max="50" value="0">
                    <label for="vibrato-rate">速さ:</label>
                    <input type="range" id="vibrato-rate" min="0" max="10" step="0.1" value="0">
                </div>
            </div>
        </div>
    </main>
    
    <script>
        // 設定
        const NOTE_WIDTH = 50;
        const NOTE_HEIGHT = 20;
        const PITCH_RANGE = 24;
        const PITCH_OFFSET = 60;
        const TEMPO = 120;
        const T_PER_BEAT = 60 / TEMPO;

        // グローバル変数
        let audioContext;
        let masterGain;
        const audioBuffers = {};
        const notes = [];
        const phonemes = ['a', 'i', 'u', 'e', 'o'];
        
        let isPlaying = false;
        let selectedNote = null;
        let isDragging = false;
        let dragType = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let originalNoteData = {};

        // UI要素
        const pianoRollContainer = document.getElementById('piano-roll-container');
        const playBtn = document.getElementById('play-btn');
        const stopBtn = document.getElementById('stop-btn');
        const editorPanel = document.getElementById('editor-panel');
        const pitchEditorCanvas = document.getElementById('pitch-editor');
        const envelopeEditorCanvas = document.getElementById('envelope-editor');
        const vibratoDepthInput = document.getElementById('vibrato-depth');
        const vibratoRateInput = document.getElementById('vibrato-rate');
        
        const pitchEditorCtx = pitchEditorCanvas.getContext('2d');
        const envelopeEditorCtx = envelopeEditorCanvas.getContext('2d');

        // ====== 初期化 ======
        async function loadAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);

            for (const phoneme of phonemes) {
                try {
                    const response = await fetch(`audio/${phoneme}.wav`);
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffers[phoneme] = await audioContext.decodeAudioData(arrayBuffer);
                    console.log(`Loaded ${phoneme}.wav`);
                } catch (error) {
                    console.error(`Failed to load ${phoneme}.wav`, error);
                }
            }
        }

        function drawGrid() {
            pianoRollContainer.innerHTML = '';
            const numBeats = Math.max(32, Math.ceil(pianoRollContainer.scrollWidth / NOTE_WIDTH / 4) * 4);
            const containerHeight = PITCH_RANGE * NOTE_HEIGHT;
            pianoRollContainer.style.height = `${containerHeight}px`;

            for (let i = 0; i < numBeats * 4; i++) {
                const line = document.createElement('div');
                line.className = 'piano-grid-line';
                line.style.width = '1px';
                line.style.height = '100%';
                line.style.left = `${i * NOTE_WIDTH / 4}px`;
                if (i % 4 === 0) {
                    line.classList.add('bar');
                }
                pianoRollContainer.appendChild(line);
            }
            for (let i = 0; i < PITCH_RANGE; i++) {
                const line = document.createElement('div');
                line.className = 'piano-grid-line';
                line.style.height = '1px';
                line.style.width = '100%';
                line.style.top = `${i * NOTE_HEIGHT}px`;
                pianoRollContainer.appendChild(line);
            }
        }

        function drawNotes() {
            document.querySelectorAll('.note').forEach(el => el.remove());
            notes.forEach(note => {
                const noteEl = document.createElement('div');
                noteEl.className = `note ${note === selectedNote ? 'selected' : ''}`;
                noteEl.dataset.noteId = note.id;
                noteEl.style.left = `${note.time * NOTE_WIDTH}px`;
                noteEl.style.top = `${(PITCH_RANGE - 1 - (note.pitch - PITCH_OFFSET)) * NOTE_HEIGHT}px`;
                noteEl.style.width = `${note.duration * NOTE_WIDTH}px`;
                noteEl.style.height = `${NOTE_HEIGHT}px`;

                const lyricsEl = document.createElement('div');
                lyricsEl.className = 'note-lyrics';
                lyricsEl.textContent = note.phoneme;
                noteEl.appendChild(lyricsEl);
                
                // サイズ変更ハンドル
                const rightHandle = document.createElement('div');
                rightHandle.className = 'handle right';
                noteEl.appendChild(rightHandle);

                pianoRollContainer.appendChild(noteEl);
            });
        }

        function refreshUI() {
            drawGrid();
            drawNotes();
            if (selectedNote) {
                showEditorPanel();
            } else {
                hideEditorPanel();
            }
        }
        
        // ====== ノートの操作 ======
        pianoRollContainer.addEventListener('mousedown', (e) => {
            if (isPlaying) return;
            const noteEl = e.target.closest('.note');

            if (noteEl) {
                const noteId = noteEl.dataset.noteId;
                selectedNote = notes.find(n => n.id === noteId);
                updateSelection();
                showEditorPanel();
                
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                originalNoteData = {
                    time: selectedNote.time,
                    pitch: selectedNote.pitch,
                    duration: selectedNote.duration
                };

                if (e.target.classList.contains('handle')) {
                    dragType = 'resize';
                } else {
                    dragType = 'move';
                }
            } else {
                selectedNote = null;
                updateSelection();
                hideEditorPanel();
                
                isDragging = true;
                dragType = 'create';
                dragStartX = e.clientX + pianoRollContainer.scrollLeft;
                dragStartY = e.clientY + pianoRollContainer.scrollTop;
            }
        });

        pianoRollContainer.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const currentX = e.clientX;
            const currentY = e.clientY;

            if (dragType === 'move' && selectedNote) {
                const dx = currentX - dragStartX;
                const dy = currentY - dragStartY;
                const newTime = Math.round(originalNoteData.time + dx / NOTE_WIDTH);
                const newPitch = Math.round(originalNoteData.pitch - dy / NOTE_HEIGHT);
                
                selectedNote.time = Math.max(0, newTime);
                selectedNote.pitch = Math.min(PITCH_RANGE - 1 + PITCH_OFFSET, Math.max(PITCH_OFFSET, newPitch));
                refreshUI();
            } else if (dragType === 'resize' && selectedNote) {
                const dx = currentX - dragStartX;
                const newDuration = Math.round(originalNoteData.duration + dx / NOTE_WIDTH);
                selectedNote.duration = Math.max(0.5, newDuration);
                refreshUI();
            }
        });

        pianoRollContainer.addEventListener('mouseup', () => {
            if (isDragging && dragType === 'create') {
                const x = dragStartX;
                const y = dragStartY;
                const time = Math.floor(x / NOTE_WIDTH);
                const pitchIndex = Math.floor(y / NOTE_HEIGHT);
                const pitch = PITCH_RANGE - 1 - pitchIndex + PITCH_OFFSET;

                const phoneme = prompt('歌詞を入力してください (例: a, i, u, e, o)', 'a');
                if (phoneme && phonemes.includes(phoneme)) {
                    const newNote = {
                        id: Date.now().toString(),
                        time: time,
                        pitch: pitch,
                        duration: 1,
                        phoneme: phoneme,
                        envelope: { attack: 0.1, decay: 0.1, sustain: 0.8, release: 0.2 },
                        vibrato: { depth: 0, rate: 0 },
                        pitchBend: [{ time: 0, value: 0 }, { time: 1, value: 0 }]
                    };
                    notes.push(newNote);
                    notes.sort((a, b) => a.time - b.time);
                    selectedNote = newNote;
                    refreshUI();
                }
            }
            isDragging = false;
        });

        function updateSelection() {
            document.querySelectorAll('.note').forEach(el => el.classList.remove('selected'));
            if (selectedNote) {
                const noteEl = document.querySelector(`[data-note-id="${selectedNote.id}"]`);
                if (noteEl) noteEl.classList.add('selected');
            }
        }

        // ====== エディタパネル ======
        function showEditorPanel() {
            editorPanel.classList.remove('hidden');
            drawPitchEditor();
            drawEnvelopeEditor();
            updateVibratoInputs();
        }

        function hideEditorPanel() {
            editorPanel.classList.add('hidden');
        }

        function drawPitchEditor() {
            if (!selectedNote) return;
            const ctx = pitchEditorCtx;
            const canvas = pitchEditorCanvas;
            const { duration, pitchBend } = selectedNote;
            const noteTime = duration;

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.beginPath();
            ctx.moveTo(pitchBend[0].time * canvas.width, (1 - (pitchBend[0].value + 100) / 200) * canvas.height);
            pitchBend.forEach(point => {
                const x = point.time * canvas.width;
                const y = (1 - (point.value + 100) / 200) * canvas.height;
                ctx.lineTo(x, y);
            });
            ctx.strokeStyle = '#007BFF';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawEnvelopeEditor() {
            if (!selectedNote) return;
            const ctx = envelopeEditorCtx;
            const canvas = envelopeEditorCanvas;
            const { envelope } = selectedNote;
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const attackX = envelope.attack * canvas.width;
            const sustainX = canvas.width;
            const releaseX = (1 - envelope.release) * canvas.width;
            const sustainY = (1 - envelope.sustain) * canvas.height;
            
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            ctx.lineTo(attackX, 0); // アタック
            ctx.lineTo(releaseX, 0); // サスティン
            ctx.lineTo(canvas.width, canvas.height); // リリース
            ctx.strokeStyle = '#66BB6A';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function updateVibratoInputs() {
            vibratoDepthInput.value = selectedNote.vibrato.depth;
            vibratoRateInput.value = selectedNote.vibrato.rate;
        }

        vibratoDepthInput.addEventListener('input', () => {
            if (selectedNote) {
                selectedNote.vibrato.depth = parseFloat(vibratoDepthInput.value);
            }
        });

        vibratoRateInput.addEventListener('input', () => {
            if (selectedNote) {
                selectedNote.vibrato.rate = parseFloat(vibratoRateInput.value);
            }
        });
        
        // ====== 再生機能 ======
        function playNote(note, time) {
            if (!audioBuffers[note.phoneme]) return;

            const source = audioContext.createBufferSource();
            source.buffer = audioBuffers[note.phoneme];

            const gainNode = audioContext.createGain();
            const pitchShifter = audioContext.createGain();

            source.connect(pitchShifter);
            pitchShifter.connect(gainNode);
            gainNode.connect(masterGain);

            const noteDuration = note.duration * T_PER_BEAT;
            const now = audioContext.currentTime;

            // エンベロープ
            const attackEnd = now + time + note.envelope.attack * noteDuration;
            const releaseStart = now + time + noteDuration;
            
            gainNode.gain.setValueAtTime(0, now + time);
            gainNode.gain.linearRampToValueAtTime(1, attackEnd);
            gainNode.gain.linearRampToValueAtTime(note.envelope.sustain, attackEnd);
            gainNode.gain.linearRampToValueAtTime(0, releaseStart);

            // ピッチカーブ
            note.pitchBend.forEach(point => {
                const bendTime = now + time + point.time * noteDuration;
                const bendValue = Math.pow(2, point.value / 1200);
                source.playbackRate.linearRampToValueAtTime(Math.pow(2, (note.pitch - 60) / 12) * bendValue, bendTime);
            });

            // ビブラート
            if (note.vibrato.depth > 0 && note.vibrato.rate > 0) {
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();

                lfo.type = 'sine';
                lfo.frequency.setValueAtTime(note.vibrato.rate, now + time);
                lfoGain.gain.setValueAtTime(note.vibrato.depth, now + time);

                lfo.connect(lfoGain);
                lfoGain.connect(source.playbackRate);

                lfo.start(now + time);
                lfo.stop(now + time + noteDuration);
            }
            
            source.start(now + time);
            source.stop(now + time + noteDuration);
        }

        function scheduleNotes() {
            const now = audioContext.currentTime;
            notes.forEach(note => {
                const noteStartTime = now + note.time * T_PER_BEAT;
                playNote(note, noteStartTime);
            });
        }

        playBtn.addEventListener('click', () => {
            if (isPlaying) return;
            isPlaying = true;
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            scheduleNotes();
            console.log('再生開始');
        });

        stopBtn.addEventListener('click', () => {
            if (!isPlaying) return;
            isPlaying = false;
            masterGain.disconnect();
            masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            console.log('再生停止');
        });

        // ページ読み込み時の処理
        loadAudio().then(() => {
            refreshUI();
            window.addEventListener('resize', refreshUI);
        });
    </script>
</body>
</html>
